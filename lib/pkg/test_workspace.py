from __future__ import absolute_import
from __future__ import division
from __future__ import unicode_literals
from __future__ import print_function

from ..test import TestCase
from . import workspace as m

import os
import zipfile

from .. import tech
from .archive import Archive
from . import layouts

write_file = tech.fs.write_file
ensure_directory = tech.fs.ensure_directory
temp_dir = tech.fs.temp_dir
timestamp = tech.timestamp.timestamp
Path = tech.fs.Path

A_PACKAGE_UUID = 'autogenerated uuid'


class Test_create(TestCase):

    def test_valid(self):
        self.given_an_empty_directory()
        self.when_initialized()
        self.then_directory_is_a_valid_pkg_dir()

    def test_has_no_inputs(self):
        self.given_an_empty_directory()
        self.when_initialized()
        self.then_workspace_has_no_inputs()

    def test_has_specified_uuid(self):
        self.given_an_empty_directory()
        self.when_initialized()
        self.then_workspace_has_the_specified_uuid()

    # implementation

    __workspace_dir = None

    @property
    def workspace(self):
        return m.Workspace(self.__workspace_dir)

    def given_an_empty_directory(self):
        self.__workspace_dir = self.new_temp_dir()

    def when_initialized(self):
        self.workspace.create(A_PACKAGE_UUID)

    def then_directory_is_a_valid_pkg_dir(self):
        self.assertTrue(self.workspace.is_valid)

    def then_workspace_has_no_inputs(self):
        self.assertFalse(self.workspace.has_input('pkg1'))
        self.assertFalse(self.workspace.is_loaded('pkg1'))
        self.assertFalse(self.workspace.inputs)

    def then_workspace_has_the_specified_uuid(self):
        self.assertEquals(A_PACKAGE_UUID, self.workspace.uuid)


class Test_pack(TestCase):

    def test_creates_valid_archive(self):
        self.given_a_package_directory()
        self.when_archived()
        self.then_archive_is_valid_package()

    def test_archives_all_content(self):
        self.given_a_package_directory()
        self.when_archived()
        self.then_archive_contains_files_from_package_directory()

    # implementation

    __workspace_dir = None
    __zipdir = None
    __zipfile = None
    __SOURCE1 = b's1'
    __SOURCE2 = b's2'
    __OUTPUT1 = b'o1'
    assert __SOURCE2 != __SOURCE1

    @property
    def workspace(self):
        return m.Workspace(self.__workspace_dir)

    def given_a_package_directory(self):
        self.__workspace_dir = self.new_temp_dir()
        self.workspace.create(A_PACKAGE_UUID)
        write_file(self.__workspace_dir / 'output/output1', self.__OUTPUT1)
        write_file(self.__workspace_dir / 'source1', self.__SOURCE1)
        ensure_directory(self.__workspace_dir / 'subdir')
        write_file(self.__workspace_dir / 'subdir/source2', self.__SOURCE2)

    def when_archived(self):
        self.__zipdir = self.new_temp_dir()
        self.__zipfile = self.__zipdir / 'pkg.zip'
        self.workspace.pack(self.__zipfile, timestamp())

    def then_archive_contains_files_from_package_directory(self):
        z = zipfile.ZipFile(self.__zipfile)
        l = layouts.Archive

        self.assertEquals(self.__OUTPUT1, z.read(l.DATA / 'output1'))
        self.assertEquals(self.__SOURCE1, z.read(l.CODE / 'source1'))
        self.assertEquals(self.__SOURCE2, z.read(l.CODE / 'subdir/source2'))

        files = z.namelist()
        self.assertIn(l.PKGMETA, files)
        self.assertIn(l.CHECKSUMS, files)

    def then_archive_is_valid_package(self):
        pkg = Archive(self.__zipfile)
        self.assertTrue(pkg.is_valid)


class Test_pack_stability(TestCase):

    def test_directory_name_data_and_timestamp_determines_versions(self):
        TS = '20150910_093724_802366'

        # note: it is important to create the same package in
        # two different directories
        def make_pkg():
            output = self.new_temp_dir() / 'pkg.zip'
            ws = m.Workspace(self.new_temp_dir() / 'a package')
            ws.create(A_PACKAGE_UUID)
            write_file(ws.directory / 'source1', 'code to produce output')
            write_file(ws.directory / 'output/output1', TS)
            ws.pack(output, TS)
            return Archive(output)

        pkg1 = make_pkg()
        pkg2 = make_pkg()
        self.assertEquals(pkg1.version, pkg2.version)


def make_package(path, filespecs):
    with temp_dir() as root:
        workspace = m.Workspace(root)
        workspace.create(A_PACKAGE_UUID)
        for filename, content in filespecs.items():
            write_file(workspace.directory / filename, content)
        workspace.pack(path, timestamp())


class Test_load(TestCase):

    def test_makes_package_files_available_under_input(self):
        self.given_a_package_directory()
        self.when_loading_a_package()
        self.then_data_files_in_package_are_available_in_workspace()

    def test_loaded_inputs_are_read_only(self):
        self.given_a_package_directory()
        self.when_loading_a_package()
        self.then_extracted_files_under_input_are_readonly()

    def test_load_adds_input_to_pkgmeta(self):
        self.given_a_package_directory()
        self.when_loading_a_package()
        self.then_input_info_is_added_to_pkgmeta()

    def test_loading_more_than_one_package(self):
        self.given_a_package_directory()
        self.when_loading_a_package()
        self.then_another_package_can_be_loaded()

    # implementation

    __workspace_dir = None

    @property
    def workspace(self):
        return m.Workspace(self.__workspace_dir)

    def given_a_package_directory(self):
        self.__workspace_dir = self.new_temp_dir()
        self.workspace.create(A_PACKAGE_UUID)

    def _load_a_package(self, input_nick):
        path_of_pkg_to_load = self.new_temp_dir() / 'pkg.zip'
        make_package(
            path_of_pkg_to_load,
            {
                'output/output1':
                'data for {}'.format(input_nick).encode('utf-8')
            }
        )
        self.workspace.load(input_nick, Archive(path_of_pkg_to_load))

    def when_loading_a_package(self):
        self._load_a_package('pkg1')

    def then_data_files_in_package_are_available_in_workspace(self):
        with open(self.__workspace_dir / 'input/pkg1/output1', 'rb') as f:
            self.assertEquals(b'data for pkg1', f.read())

    def then_extracted_files_under_input_are_readonly(self):
        root = self.__workspace_dir / 'input/pkg1'
        self.assertTrue(os.path.exists(root))
        self.assertRaises(IOError, open, root / 'output1', 'ab')
        self.assertRaises(IOError, open, root / 'new-file', 'wb')

    def then_input_info_is_added_to_pkgmeta(self):
        self.assertTrue(self.workspace.has_input('pkg1'))
        self.assertTrue(self.workspace.is_loaded('pkg1'))

    def then_another_package_can_be_loaded(self):
        self._load_a_package('pkg2')


def unzip(archive_path, directory):
    ensure_directory(directory)
    with zipfile.ZipFile(archive_path) as z:
        z.extractall(directory)


def zip_up(directory, archive_path):
    with zipfile.ZipFile(archive_path, 'w') as z:
        def add(path, zip_path):
            if os.path.isdir(path):
                for name in os.listdir(path):
                    add(path / name, zip_path / name)
            else:
                z.write(path, zip_path)
        add(directory, Path('/'))


class Test_is_valid(TestCase):

    # fixtures

    def workspace(self):
        workspace = m.Workspace(self.new_temp_dir())
        workspace.create(A_PACKAGE_UUID)
        return workspace

    def timestamp(self):
        return '20150930_093724_802366'

    def archive_path(self, workspace, timestamp):
        archive_path = self.new_temp_dir() / 'package.zip'
        workspace.pack(archive_path, timestamp)
        return archive_path

    def archive_with_two_files_path(self, workspace, timestamp):
        write_file(workspace.directory / 'code1', 'code1')
        write_file(workspace.directory / 'output/data1', 'data1')
        return self.archive_path(workspace, timestamp)

    def unzipped_archive_path(self, archive_with_two_files_path):
        path = self.new_temp_dir()
        unzip(archive_with_two_files_path, path)
        return path

    def archive(self, archive_path):
        return Archive(archive_path)

    # tests

    def test_newly_created_package_is_valid(self, archive):
        self.assertTrue(archive.is_valid)

    def test_adding_a_data_file_to_an_archive_makes_package_invalid(
            self, archive_path):
        with zipfile.ZipFile(archive_path, 'a') as z:
            z.writestr(layouts.Archive.DATA / 'extra_file', b'something')

        self.assertFalse(Archive(archive_path).is_valid)

    def test_adding_a_code_file_to_an_archive_makes_package_invalid(
            self, archive_path):
        with zipfile.ZipFile(archive_path, 'a') as z:
            z.writestr(layouts.Archive.CODE / 'extra_file', b'something')

        self.assertFalse(Archive(archive_path).is_valid)

    def test_unzipping_and_zipping_an_archive_remains_valid(
            self, unzipped_archive_path):
        rezipped_archive_path = self.new_temp_dir() / 'rezipped_archive.zip'
        zip_up(unzipped_archive_path, rezipped_archive_path)

        self.assertTrue(Archive(rezipped_archive_path).is_valid)

    def test_deleting_a_checksummed_file_makes_the_package_invalid(
            self, unzipped_archive_path):
        os.remove(unzipped_archive_path / layouts.Archive.CODE / 'code1')
        modified_archive_path = self.new_temp_dir() / 'modified_archive.zip'
        zip_up(unzipped_archive_path, modified_archive_path)

        self.assertFalse(Archive(modified_archive_path).is_valid)

    def test_changing_a_file_makes_the_package_invalid(
            self, unzipped_archive_path):
        write_file(
            unzipped_archive_path / layouts.Archive.CODE / 'code1', b'HACKED')
        modified_archive_path = self.new_temp_dir() / 'modified_archive.zip'
        zip_up(unzipped_archive_path, modified_archive_path)

        self.assertFalse(Archive(modified_archive_path).is_valid)
